/*
题目：
	统计整数的二进制中1的个数（注意：这里的二进制是补码的意思）

分析：
（1）最简单的解法：将整数不断右移，将最低位的值加起来即可。
（2）利用n&(n-1)：n&(n-1)能统计出该数是不是2的n次幂。同理，n = n&(n-1)直至n=0；
（3）平行算法：先将n写成二进制形式，然后相邻位相加，重复这个过程，直到只剩下一位。(其实我没有弄懂具体原理)

测试案例：
（1）正常情况：
	n = 7;		//补码为0000 0000 0000 0000 0000 0000 0000 0111
	n = 5;		//补码为0000 0000 0000 0000 0000 0000 0000 0101
	n = 0;		//补码为0000 0000 0000 0000 0000 0000 0000 0000
	n = -5;		//补码为1111 1111 1111 1111 1111 1111 1111 1011
	n = -7;		//补码为1111 1111 1111 1111 1111 1111 1111 1001
（2）不正常情况：
	无
（3）边界情况：
	n = MAX_INT;
	n = -MAX_INT;
	n = MIN_INT;
*/
#include <stdio.h>

#define MAX_INT 2147483647		//补码为0111 1111 1111 1111 1111 1111 1111 1111
#define MIN_INT (-MAX_INT-1)	//补码为1000 0000 0000 0000 0000 0000 0000 0000
					  //-MAX_INT的补码为1000 0000 0000 0000 0000 0000 0000 0001
int count_1(int n);
int count_2(int n);
int count_3(unsigned int n);

int main()
{
	int n = -7;
	int result1, result2, result3;

	n = 7;		//补码为0000 0000 0000 0000 0000 0000 0000 0111
	n = 5;		//补码为0000 0000 0000 0000 0000 0000 0000 0101
	n = 0;		//补码为0000 0000 0000 0000 0000 0000 0000 0000
	n = -5;		//补码为1111 1111 1111 1111 1111 1111 1111 1011
	n = -7;		//补码为1111 1111 1111 1111 1111 1111 1111 1001

	n = MAX_INT;	//补码为0111 1111 1111 1111 1111 1111 1111 1111
	n = -MAX_INT;	//补码为1000 0000 0000 0000 0000 0000 0000 0001
	n = MIN_INT;	//补码为1000 0000 0000 0000 0000 0000 0000 0000

	result1 = count_1(n);
	printf("result1 = %d\n",result1);

	result2 = count_2(n);
	printf("result2 = %d\n", result2);
	
	result3 = count_3(n);
	printf("result3 = %d\n", result3);

	return 0;
}

//注意：n为负数的时候
//有符号整型 n>>1，是算术右移，符号位不会移动，while(n)程序会死掉
int count_1(int n)
{
	int count = 0;
	unsigned int flag = 1;
	while (flag)
	{
		if (n & flag)
			count++;
		flag = flag << 1;
	}//while

	return count;
}

int count_2(int n)
{
	int count = 0;
	while (n)
	{
		n &= (n - 1); /*每执行一次，都会抹掉最右端的1*/
		++count;
	}//while
	return count;
}

//注意输入转换为unsigned int
//写成((n >> 1) & 0x55555555)，OK
//改成(n >> 1) & 0x55555555，就会出错，没有找到原因
int count_3(unsigned int n)
{
	n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
	n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
	n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
	n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
	n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
	return n;
}
